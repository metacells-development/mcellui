---
phase: 17-registry-structure-metadata
plan: 03
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - packages/registry/registry.schema.json
  - packages/registry/scripts/validate-registry.ts
  - packages/registry/package.json
autonomous: true

must_haves:
  truths:
    - "Registry JSON Schema validates current registry.json successfully"
    - "Schema rejects invalid entries (missing name, wrong type, invalid category)"
    - "Validation script can be run via npm script"
  artifacts:
    - path: "packages/registry/registry.schema.json"
      provides: "JSON Schema definition for registry format"
      contains: "schemaVersion"
    - path: "packages/registry/scripts/validate-registry.ts"
      provides: "Validation script using Ajv"
      contains: "ajv"
    - path: "packages/registry/package.json"
      provides: "npm script to run validation"
      contains: "validate"
  key_links:
    - from: "packages/registry/registry.schema.json"
      to: "packages/registry/registry.json"
      via: "$schema reference and structural validation"
      pattern: "registry.schema.json"
    - from: "packages/registry/scripts/validate-registry.ts"
      to: "packages/registry/registry.schema.json"
      via: "Ajv loads and compiles schema"
      pattern: "registry.schema.json"
---

<objective>
Create JSON Schema and validation script to enforce registry quality going forward.

Purpose: Fulfills REG-04 (extensible structure supporting future additions). A JSON Schema ensures new components added to the registry meet all metadata requirements. The validation script enables CI enforcement.

Output: registry.schema.json, validate-registry.ts script, npm validate:registry script.
</objective>

<execution_context>
@/Users/johanneschristler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/johanneschristler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-registry-structure-metadata/17-RESEARCH.md
@.planning/phases/17-registry-structure-metadata/17-01-SUMMARY.md

Key context:
- Registry fields per component: name, displayName, type, description, category, status, files, dependencies, registryDependencies, expoGo
- Registry root fields: $schema, schemaVersion, name, version, components
- type values: ui, primitive, hook, block, screen
- status values: stable, beta, experimental
- 21 categories: Authentication, Content, Dashboard, Data Display, E-commerce, Feedback, Forms, Inputs, Layout, Marketing, Media, Messaging, Mobile, Navigation, Onboarding, Overlay, Productivity, Profile, Settings, Social, Support
- Naming rules: blocks end with -block, screens end with -screen
- Research recommends: Ajv + ajv-formats for validation
- registry package.json already has: "build:registry": "node scripts/build-registry.js"
- No existing schema file or validation script
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JSON Schema for registry</name>
  <files>packages/registry/registry.schema.json</files>
  <action>
Create `packages/registry/registry.schema.json` defining the complete registry structure.

Schema requirements:
1. Root object:
   - `$schema` (string, optional) — self-referencing schema URI
   - `schemaVersion` (string, required) — e.g., "1.0"
   - `name` (string, required)
   - `version` (string, required)
   - `components` (array, required) — array of component items

2. Component item:
   - `name` (string, required) — kebab-case identifier, pattern: `^[a-z][a-z0-9]*(-[a-z0-9]+)*$`
   - `displayName` (string, optional) — human-readable name
   - `type` (string, required) — enum: `["ui", "primitive", "hook", "block", "screen"]`
   - `description` (string, required) — min length 10
   - `category` (string, required) — enum of all 21 categories
   - `status` (string, required) — enum: `["stable", "beta", "experimental"]`
   - `files` (array, required) — at least 1 item, each is a string
   - `dependencies` (array, optional) — npm package names
   - `devDependencies` (array, optional) — npm dev package names
   - `registryDependencies` (array, optional) — other mcellui component names
   - `expoGo` (boolean, optional) — defaults true

3. Use JSON Schema draft-2020-12 or draft-07 (Ajv supports both)

4. Add conditional validation:
   - If `type` is `"block"`, `name` must end with `-block` (pattern: `-block$`)
   - If `type` is `"screen"`, `name` must end with `-screen` (pattern: `-screen$`)

Use `if/then` or `allOf` with `if/then` for conditional name patterns.
  </action>
  <verify>
```bash
# Schema is valid JSON
node -e "JSON.parse(require('fs').readFileSync('packages/registry/registry.schema.json','utf8')); console.log('Valid JSON');"
```
  </verify>
  <done>registry.schema.json exists with complete field definitions, category enum, type enum, and conditional block/screen naming rules</done>
</task>

<task type="auto">
  <name>Task 2: Create validation script and npm command</name>
  <files>
    packages/registry/scripts/validate-registry.ts
    packages/registry/package.json
  </files>
  <action>
**Step 1: Install Ajv**

```bash
cd packages/registry
npm install -D ajv ajv-formats
```

**Step 2: Create validation script at `packages/registry/scripts/validate-registry.ts`**

The script should:
1. Load registry.schema.json
2. Load registry.json
3. Compile schema with Ajv (allErrors: true)
4. Validate registry against schema
5. Run additional checks that JSON Schema cannot express:
   - All `registryDependencies` entries reference component names that exist in registry
   - All `files` paths reference files that actually exist on disk
   - No duplicate component names
6. Print results:
   - On success: "Registry validation passed (N components)"
   - On failure: List all errors with component name and field, exit code 1

Use CommonJS (require) since the scripts directory likely runs with Node.js directly, not through TypeScript compilation. Actually, check the existing `scripts/build-registry.js` — if it uses CommonJS, match that style. The script name can be `.js` instead of `.ts` if existing scripts are `.js`.

If existing script is JS, create `validate-registry.js` instead.

**Step 3: Add npm script to package.json**

Add to `scripts` in `packages/registry/package.json`:
```json
"validate:registry": "node scripts/validate-registry.js"
```

**Step 4: Run validation**

Execute `npm run validate:registry` in packages/registry to confirm it passes against the current registry.
  </action>
  <verify>
```bash
cd packages/registry
npm run validate:registry
# Should output "Registry validation passed (101 components)" or similar
# Exit code 0

# Test that validation catches errors (optional sanity check)
```
  </verify>
  <done>Validation script runs successfully against current registry, checks schema compliance + referential integrity + file existence + no duplicates; npm script configured</done>
</task>

</tasks>

<verification>
1. `packages/registry/registry.schema.json` exists and is valid JSON
2. Schema defines all required fields with correct types and enums
3. Schema enforces -block suffix for blocks and -screen suffix for screens
4. `packages/registry/scripts/validate-registry.js` (or .ts) exists
5. `npm run validate:registry` passes against current registry (exit code 0)
6. Validation script checks referential integrity (registryDependencies reference real components)
7. Validation script checks file existence
</verification>

<success_criteria>
- JSON Schema covers all registry fields with correct constraints
- Validation script validates current registry successfully
- Script catches common errors (missing fields, bad names, stale references)
- npm script configured for easy CI integration
</success_criteria>

<output>
After completion, create `.planning/phases/17-registry-structure-metadata/17-03-SUMMARY.md`
</output>
