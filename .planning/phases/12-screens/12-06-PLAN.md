---
phase: 12-screens
plan: 06
type: execute
wave: 3
depends_on: ["12-02", "12-03", "12-04", "12-05"]
files_modified:
  - apps/demo/components/demos/screens-demo.tsx
autonomous: false

must_haves:
  truths:
    - "Demo uses actual registry screen components (not inline previews)"
    - "All 19 screens are showcased with realistic data"
    - "Screens demonstrate loading, error, and empty states where applicable"
    - "Authentication flows show form validation feedback"
    - "Screen components accept loading/error/empty props (already implemented in registry)"
  artifacts:
    - path: "apps/demo/components/demos/screens-demo.tsx"
      provides: "Complete screens demo with actual registry components"
      contains: "LoginScreen|FeedScreen|CartScreen"
  key_links:
    - from: "apps/demo/components/demos/screens-demo.tsx"
      to: "packages/registry/screens/*"
      via: "imports from @/components/screens"
      pattern: "import.*Screen.*from.*screens"
    - from: "apps/demo/components/demos/screens-demo.tsx"
      to: "mock data types"
      via: "TypeScript interfaces for demo data"
      pattern: "interface.*Mock|type.*Mock|MOCK_"
---

<objective>
Enhance screens demo to use actual registry screen components instead of inline preview implementations, demonstrating all states (loading, error, empty) and form validation patterns.

Purpose: Demo app should showcase production-quality screens with realistic data and complete state coverage, not simplified previews.
Output: Complete screens demo using actual registry components with all states demonstrated.

Note: Screen components already support loading/error/empty state props (e.g., LoginScreen has `loading?: boolean` and `error?: string`, FeedScreen has `emptyTitle`, `emptyMessage`, `loadingMore`). This plan demonstrates these existing capabilities.
</objective>

<execution_context>
@/Users/johanneschristler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/johanneschristler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-screens/12-01-SUMMARY.md
@.planning/phases/12-screens/12-02-SUMMARY.md
@.planning/phases/12-screens/12-03-SUMMARY.md
@.planning/phases/12-screens/12-04-SUMMARY.md
@.planning/phases/12-screens/12-05-SUMMARY.md

@apps/demo/components/demos/screens-demo.tsx
@packages/registry/screens/login-screen.tsx
@packages/registry/screens/feed-screen.tsx
@packages/registry/screens/cart-screen.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace inline previews with actual registry screen imports and define mock data types</name>
  <files>apps/demo/components/demos/screens-demo.tsx</files>
  <action>
Replace inline *ScreenPreview components with actual registry screen imports:

1. Add imports for all 19 screens from registry:
```typescript
import { LoginScreen } from '@/components/screens/login-screen';
import { SignupScreen } from '@/components/screens/signup-screen';
import { OTPVerificationScreen } from '@/components/screens/otp-verification-screen';
import { ProfileScreen } from '@/components/screens/profile-screen';
import { SettingsScreen } from '@/components/screens/settings-screen';
import { FeedScreen, FeedPost } from '@/components/screens/feed-screen';
import { ChatScreen, ChatMessage } from '@/components/screens/chat-screen';
import { NotificationsScreen, NotificationItem } from '@/components/screens/notifications-screen';
import { CommentsScreen, Comment } from '@/components/screens/comments-screen';
import { CartScreen, CartItem } from '@/components/screens/cart-screen';
import { CheckoutScreen } from '@/components/screens/checkout-screen';
import { ProductDetailScreen, Product } from '@/components/screens/product-detail-screen';
import { OrderHistoryScreen, Order } from '@/components/screens/order-history-screen';
import { HomeScreen } from '@/components/screens/home-screen';
import { AccountScreen } from '@/components/screens/account-screen';
import { SearchScreen } from '@/components/screens/search-screen';
import { FollowersScreen, Follower } from '@/components/screens/followers-screen';
import { OnboardingScreen } from '@/components/screens/onboarding-screen';
import { HelpScreen } from '@/components/screens/help-screen';
```

2. Define TypeScript interfaces for mock data (if not exported from screens):
```typescript
// Define mock data interfaces matching screen prop types
interface MockFeedPost {
  id: string;
  user: { name: string; avatar?: string };
  content: string;
  time: string;
  likes: number;
  comments: number;
  liked: boolean;
  hasImage?: boolean;
}

interface MockCartItem {
  id: string;
  product: { name: string; price: number; image?: string };
  quantity: number;
}

interface MockNotification {
  id: string;
  type: 'like' | 'comment' | 'follow' | 'mention';
  user: { name: string; avatar?: string };
  message: string;
  time: string;
  read: boolean;
}

interface MockUserProfile {
  name: string;
  username: string;
  bio: string;
  avatar?: string;
  stats: { posts: number; followers: number; following: number };
}
```

3. For each Modal, replace the inline Preview component with the actual screen:

Before:
```typescript
<Modal visible={activeScreen === 'login'} animationType="slide">
  <LoginScreenPreview onClose={() => setActiveScreen(null)} />
</Modal>
```

After:
```typescript
<Modal visible={activeScreen === 'login'} animationType="slide">
  <LoginScreen
    onLogin={async (email, password) => {
      console.log('Login:', email);
      await new Promise(r => setTimeout(r, 1500));
      setActiveScreen(null);
    }}
    onSocialLogin={(provider) => console.log('Social:', provider)}
    onForgotPassword={() => Alert.alert('Forgot Password', 'Check your email')}
    onSignUp={() => setActiveScreen('signup')}
  />
</Modal>
```

4. Remove all inline *ScreenPreview function components (LoginScreenPreview, SignUpScreenPreview, etc.) after replacing with actual imports.

5. Each screen modal needs:
   - onBack or equivalent close handler -> setActiveScreen(null)
   - Realistic mock data where applicable
   - Proper prop connections
  </action>
  <verify>
grep -c "ScreenPreview" apps/demo/components/demos/screens-demo.tsx
# Should be 0 (no inline previews)
grep "import.*Screen.*from.*screens" apps/demo/components/demos/screens-demo.tsx | head -5
# Should show actual imports
grep -c "interface Mock\|type Mock" apps/demo/components/demos/screens-demo.tsx
# Should show mock data type definitions (or imports from screens)
  </verify>
  <done>All 19 screens use actual registry components with properly typed mock data</done>
</task>

<task type="auto">
  <name>Task 2: Add state demonstrations and realistic mock data</name>
  <files>apps/demo/components/demos/screens-demo.tsx</files>
  <action>
Enhance screen demonstrations with state coverage and realistic data:

1. Add useState hooks for demo states:
```typescript
const [loginLoading, setLoginLoading] = useState(false);
const [loginError, setLoginError] = useState<string | undefined>();
const [feedPosts, setFeedPosts] = useState<MockFeedPost[]>([]);
const [cartItems, setCartItems] = useState<MockCartItem[]>([]);
const [notifications, setNotifications] = useState<MockNotification[]>([]);
// ... etc for other screens
```

2. Create mock data constants for screens that need them:
```typescript
const MOCK_FEED_POSTS: MockFeedPost[] = [
  { id: '1', user: { name: 'Sarah Miller', avatar: 'S' }, content: 'Just shipped a new feature!', likes: 42, comments: 8, time: '2h ago', liked: false },
  { id: '2', user: { name: 'John Davis', avatar: 'J' }, content: 'Check out this sunset photo...', likes: 156, comments: 23, time: '4h ago', liked: true },
  // ... more posts
];

const MOCK_CART_ITEMS: MockCartItem[] = [
  { id: '1', product: { name: 'Wireless Headphones', price: 89.99, image: undefined }, quantity: 1 },
  { id: '2', product: { name: 'Phone Case', price: 29.99, image: undefined }, quantity: 2 },
];

const MOCK_NOTIFICATIONS: MockNotification[] = [
  { id: '1', type: 'like', user: { name: 'Alex' }, message: 'liked your post', time: '5m ago', read: false },
  { id: '2', type: 'follow', user: { name: 'Sam' }, message: 'started following you', time: '1h ago', read: true },
];

const MOCK_USER_PROFILE: MockUserProfile = {
  name: 'Jane Doe',
  username: '@janedoe',
  bio: 'Designer & Developer',
  stats: { posts: 42, followers: 1200, following: 350 }
};
```

3. Add state toggle demonstrations for key screens:

For LoginScreen - demonstrate loading and error state props:
```typescript
<LoginScreen
  loading={loginLoading}
  error={loginError}
  onLogin={async (email, password) => {
    setLoginLoading(true);
    setLoginError(undefined);
    await new Promise(r => setTimeout(r, 2000));
    if (email === 'error@test.com') {
      setLoginError('Invalid credentials');
    } else {
      setActiveScreen(null);
    }
    setLoginLoading(false);
  }}
  ...
/>
```

For FeedScreen - demonstrate empty state props:
```typescript
<FeedScreen
  posts={feedPosts}
  onRefresh={async () => {
    await new Promise(r => setTimeout(r, 1000));
    setFeedPosts(MOCK_FEED_POSTS);
  }}
  emptyTitle="No posts yet"
  emptyMessage="Pull to refresh or follow people"
  loadingMore={false}
/>
```

4. Ensure each screen with async data shows:
   - Initial empty/loading state
   - Populated state after interaction
   - Error state where applicable (auth screens)
  </action>
  <verify>
grep -c "useState" apps/demo/components/demos/screens-demo.tsx
# Should show multiple state hooks (>5)
grep -c "MOCK_" apps/demo/components/demos/screens-demo.tsx
# Should show mock data constants (>3)
# Verify screens accept state props (already in registry):
grep "loading\?:" packages/registry/screens/login-screen.tsx
# Should show: loading?: boolean;
grep "emptyTitle\|emptyMessage" packages/registry/screens/feed-screen.tsx
# Should show empty state props
  </verify>
  <done>All screens demonstrate loading, error, and empty states with realistic mock data using existing screen prop support</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete screens demo using actual registry screen components with full state coverage</what-built>
  <how-to-verify>
1. Start demo app: `cd apps/demo && npx expo start`
2. Navigate to Screens section
3. Test each screen modal:
   - Login: Enter email, try submitting (shows loading), try error@test.com (shows error)
   - Feed: Check empty state, pull to refresh to populate
   - Cart: Verify items display, totals calculate
   - Profile: Check stats, tabs, follow button
   - Checkout: Walk through shipping -> payment -> review steps
4. Verify all 19 screen modals open and display correctly
5. Test dark mode toggle - screens should adapt
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build check: `cd apps/demo && npx expo export --platform web`
2. No inline previews: `grep -c "ScreenPreview" apps/demo/components/demos/screens-demo.tsx` should be 0
3. Actual imports: `grep "import.*Screen.*from.*screens" apps/demo/components/demos/screens-demo.tsx | wc -l` should be >= 15
4. State hooks present: `grep -c "useState" apps/demo/components/demos/screens-demo.tsx` should be > 5
5. Screen state prop support confirmed:
   - `grep "loading\?:" packages/registry/screens/login-screen.tsx` shows loading prop
   - `grep "error\?:" packages/registry/screens/login-screen.tsx` shows error prop
   - `grep "emptyTitle\|emptyMessage" packages/registry/screens/feed-screen.tsx` shows empty state props
</verification>

<success_criteria>
- All 19 inline *ScreenPreview components removed
- All 19 screens imported from registry
- Each screen modal uses actual registry component
- TypeScript interfaces defined for mock data (MockFeedPost, MockCartItem, etc.)
- Mock data provided for screens needing it (Feed, Cart, Notifications, etc.)
- Loading states demonstrated on auth screens (using existing loading prop)
- Empty states demonstrated on list screens (using existing emptyTitle/emptyMessage props)
- Error states demonstrated on auth screens (using existing error prop)
- Human verification confirms screens display correctly
</success_criteria>

<output>
After completion, create `.planning/phases/12-screens/12-06-SUMMARY.md`
</output>
